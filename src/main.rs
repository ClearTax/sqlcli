#![allow(clippy::clippy::needless_return)]

use clap::App;
use clap::AppSettings;
use clap::Arg;
use simple_logger::SimpleLogger;
use std::fs;
use std::io::Read;
use std::io::{self};

use sqlcli::get_projection_names;
use sqlcli::get_table_names;
use sqlcli::parse_select_statement;

fn read_stdin() -> String {
    let mut buffer = String::new();
    io::stdin()
        .read_to_string(&mut buffer)
        .expect("Could not read stdin.");
    return buffer;
}

fn read_file(path: String) -> String {
    let result = fs::read_to_string(path);
    match result {
        Ok(s) => {
            return s;
        }
        Err(_) => {
            eprintln!("Could not read input file.");
            std::process::exit(65);
        }
    }
}

fn read_file_or_stdin(path: String) -> String {
    if "-".eq(&path) {
        return read_stdin();
    }
    return read_file(path);
}

fn main() {
    let app = App::new("sqlcli")
        .version("0.1.0")
        .about("Parse sql queries and answer questions about them.")
        .arg("-d, --debug 'Turn on debug logging'")
        .subcommand(
            App::new("tables")
                .about("Print tables queried from in SQL.")
                .args(&[Arg::new("<INPUT>")
                    .required(false)
                    .default_value("-")
                    .about("File containing input SQL query. `-` (default) means STDIN.")]),
        )
        .subcommand(
            App::new("columns")
                .about("Print output column names of the SQL query.")
                .long_about("For each column, print one of the following cases:
`WILDCARD: [identifier]` -- eg: `Select *` or a `Select a.*`
`UNNAMED` -- when the column has an unnamed expression, like `select count(*) from table` 
`NAMED: [name] -- when you directly select a column (`select col1 from table1`) or use an alias (`select col1 c1 from table1`).")
                .args(&[Arg::new("<INPUT>")
                    .required(false)
                    .default_value("-")
                    .about("File containing input SQL query. `-` (default) means STDIN.")]),
        )
        .subcommand(
            App::new("ast")
                .about("Print the AST as generated by sqlparser-rs.")
                .args(&[Arg::new("<INPUT>")
                    .required(false)
                    .default_value("-")
                    .about("File containing input SQL query. `-` (default) means STDIN.")]),
        )
        .setting(AppSettings::SubcommandRequiredElseHelp);

    let matches = app.get_matches();

    if matches.is_present("debug") {
        SimpleLogger::new().init().unwrap();
    }

    if let Some(ref matches) = matches.subcommand_matches("ast") {
        let input = matches.value_of("<INPUT>").unwrap();
        let sql = read_file_or_stdin(input.to_string());
        match parse_select_statement(sql) {
            Ok(ast) => {
                println!("{:#?}", ast);
            }
            Err(e) => {
                eprintln!("Error: {:?}", e);
                std::process::exit(65) // Data error
            }
        }
    }

    if let Some(ref matches) = matches.subcommand_matches("tables") {
        let input = matches.value_of("<INPUT>").unwrap();
        let sql = read_file_or_stdin(input.to_string());
        let result = get_table_names(sql);
        match result {
            Ok(table_names) => {
                for name in table_names {
                    println!("{}", name);
                }
            }

            Err(e) => {
                eprintln!("Error: {:?}", e);
                std::process::exit(65) // Data error
            }
        }
    }

    if let Some(ref matches) = matches.subcommand_matches("columns") {
        let input = matches.value_of("<INPUT>").unwrap();
        let sql = read_file_or_stdin(input.to_string());
        let result = get_projection_names(sql);
        match result {
            Ok(column_names) => {
                for name in column_names {
                    println!("{}", name);
                }
            }

            Err(e) => {
                eprintln!("Error: {:?}", e);
                std::process::exit(65) // Data error
            }
        }
    }
}
